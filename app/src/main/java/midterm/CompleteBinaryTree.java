/*
 * This source file was generated by the Gradle 'init' task
 */
package midterm;

import java.util.LinkedList;
import java.util.Queue;

public class CompleteBinaryTree {

    private Node root;
    private int[]arr;
    private int cap;
    private int track;

    public CompleteBinaryTree() {
        this.root  = null;
        this.cap = 10;
        this.arr   = new int[cap];
        this.track = 0;

    }

    public int getRoot() {
        return root.data;
    }

    public void insert(int element) {
        if (root == null) {
            root = new Node(element);
            arr[track] = element;
            return;
        }

        Node temp = root;


        if (track >= cap){
            cap = cap * 2;
            int []history = arr;
            this.arr = new int[cap];
            int i = 0;
            while (i < track) {
                this.insert(history[i]);
                i = i + 1;
            }
        }
        this.insertHelper(temp, element);

        }

    public void insertHelper(Node temp, int element){

            if (temp.left == null) {
                temp.left = new Node(element);
                arr[track*2+1] = element;
            }

            else if (temp.right == null){
                temp.right = new Node(element);
                arr[track*2+2] = element;
                track+=1;
            }
            else{
                this.insertHelper(temp.left, element);
                this.insertHelper(temp.right, element);
                ;

            }
            return;
        }
    
    
    public void delete(int data) {
        if (root == null) {
            return;
        }

        Node temp = root;
        Node keyNode = null;
        Node lastNode = null;
        Queue<Node> queue = new LinkedList<>();
        queue.add(temp);

        while (!queue.isEmpty()) {
            temp = queue.poll();

            if (temp.data == data) 
                keyNode = temp;

            if (temp.left != null) 
                queue.add(temp.left);

            if (temp.right != null) 
                queue.add(temp.right);

            lastNode = temp;
        }

        if (keyNode == null)
            return;

        keyNode.data = lastNode.data;
        deleteLastNode(lastNode);
    }

    private void deleteLastNode(Node lastNode) {
        Node temp = root;
        Queue<Node> queue = new LinkedList<>();
        queue.add(temp);

        while (!queue.isEmpty()) {
            temp = queue.poll();

            if (temp.left == lastNode) {
                temp.left = null;
                break;
            } else if (temp.left != null)
                queue.add(temp.left);

            if (temp.right == lastNode) {
                temp.right = null;
                break;
            } else if (temp.right != null)
                queue.add(temp.right);
        }
    }


    public String toString() {
        int i = 0;
        String str = "";
        while (i <=track + 1){
            str = str + arr[i] + " ";
            i+=1;
        }
        return str;

    }

    // private String toString(Node root) {
    //     String str = "";
    //     if (root == null){
    //         return "";
    //     }
    //     while (root != null) {
    //         str = str+ root.data + " "+ this.toString(root.left) + toString(root.right);
    //     }
    //     return str;
    // }


    public static void main(String[] args) {
        CompleteBinaryTree tree = new CompleteBinaryTree();
        tree.insert(1);
        tree.insert(2);
        tree.insert(3);
        tree.insert(4);
        tree.insert(5);
        
        System.out.println(tree.getRoot());
        System.out.println(tree.root.right.data);
        System.out.println(tree.toString());
    }
}
